local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local player = game.Players.LocalPlayer

local PlaceUnit = ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("PlaceUnit")

-- ===============================
-- üîπ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏£‡∏≠‡∏ö‡∏à‡∏∏‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏ô
-- ===============================
local function randomPositionAround(pos, radius)
	radius = radius or 5
	return Vector3.new(
		pos.X + (math.random() * 2 - 1) * radius,
		pos.Y,
		pos.Z + (math.random() * 2 - 1) * radius
	)
end

local lastPositions = { raff1=nil, raff2=nil, raff3=nil }

-- ===============================
-- üîπ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏á Raff ‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏° + ‡πÑ‡∏°‡πà‡∏ä‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°
-- ===============================
local function placeUnitRafflesia(unitName, pathIndex, basePos, minDist, maxDist, radius)
	radius = radius or 5
	local newPos
	local attempts = 0

	repeat
		newPos = randomPositionAround(basePos, radius)
		attempts += 1
	until lastPositions[unitName] ~= newPos or attempts > 10

	local distanceAlong = (minDist or 7) + math.random() * ((maxDist or 10) - (minDist or 7))

	local args = {
		"unit_rafflesia",
		{
			Valid = true,
			PathIndex = pathIndex,
			Position = newPos,
			DistanceAlongPath = distanceAlong,
			CF = CFrame.new(newPos),
			Rotation = 180
		}
	}

	local ok, err = pcall(function()
		PlaceUnit:InvokeServer(unpack(args))
	end)
	if not ok then warn("PlaceUnit failed:", err) end

	lastPositions[unitName] = newPos
	return newPos
end

-- ===============================
-- üîπ ‡∏à‡∏∏‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á raff
-- ===============================
local unitBases = {
	raff1 = Vector3.new(42.814, -21.75, -45.892),
	raff2 = Vector3.new(-44.658, -21.75, -43.475),
	raff3 = Vector3.new(41.676, -21.75, -44.754)
}

local function placeRaff1() return placeUnitRafflesia("raff1", 1, unitBases.raff1, 7, 10, 5) end
local function placeRaff2() return placeUnitRafflesia("raff2", 2, unitBases.raff2, 21, 24, 5) end
local function placeRaff3() return placeUnitRafflesia("raff3", 1, unitBases.raff3, 7, 10, 5) end

-- ==================================================
-- üî• ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢: ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö ID + ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏¢‡∏π‡∏ô‡∏¥‡∏ï
-- ==================================================
local placedUnits = {}

-- üßÆ ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
local function parseNumber(str)
	str = tostring(str or "")
	local cleaned = str:gsub("[^%d]", "")
	return tonumber(cleaned) or 0
end

-- üí∞ ‡∏£‡∏≠‡∏à‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ñ‡∏∂‡∏á‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
local function waitUntilCash(target)
	local gui = player:WaitForChild("PlayerGui"):WaitForChild("GameGui")
	local cashLabel = gui.Screen.Bottom.CurrencyDisplay.Cash

	while true do
		local now = parseNumber(cashLabel.Text)
		print("‡πÄ‡∏á‡∏¥‡∏ô:", now)
		if now >= target then break end
		task.wait(1)
	end
end

-- üîé ‡∏´‡∏≤ ID ‡∏Ç‡∏≠‡∏á‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏á‡∏ß‡∏≤‡∏á
local function waitForUnitId(unitName, timeout)
	timeout = timeout or 15
	local start = tick()

	while tick() - start < timeout do
		local entities = Workspace.Map.Entities
		for _, unit in pairs(entities:GetChildren()) do
			local idAttr = unit:GetAttribute("ID")
			if unit.Name == unitName and idAttr and not placedUnits[idAttr] then
				placedUnits[idAttr] = unit
				return idAttr
			end
		end
		task.wait(0.2)
	end
	return nil
end

-- üü¢ ‡∏ß‡∏≤‡∏á‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡πÅ‡∏•‡πâ‡∏ß‡∏£‡∏≠ ID
local function placeUnitSafe(position, pathIndex)
	local id
	local attempts = 0

	repeat
		attempts += 1
		local args = {
			"unit_rafflesia",
			{
				Valid = true,
				PathIndex = pathIndex or 1,
				Position = position,
				DistanceAlongPath = 0,
				CF = CFrame.new(position),
				Rotation = 0
			}
		}

		PlaceUnit:InvokeServer(unpack(args))
		id = waitForUnitId("unit_rafflesia", 15)

		if not id then
			warn("‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à retry:", attempts)
		end
	until id or attempts >= 3

	return id
end

-- ‚¨ÜÔ∏è ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ï‡∏≤‡∏° ID
local function upgradeUnitById(id)
	if placedUnits[id] then
		ReplicatedStorage.RemoteFunctions.UpgradeUnit:InvokeServer(id)
	else
		warn("‡πÑ‡∏°‡πà‡∏û‡∏ö unit ID:", id)
	end
end

-- ===============================
-- üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
-- ===============================
local function ChooseMode()
	ReplicatedStorage.RemoteFunctions.PlaceDifficultyVote:InvokeServer("dif_apocalypse")
end

local function again()
	local r = ReplicatedStorage.RemoteFunctions.RestartGame
	pcall(function() r:InvokeServer() end)
end

-- ===============================
-- üéÆ ‡∏•‡∏π‡∏õ‡πÄ‡∏Å‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
-- ===============================
local function runGameLoop()
	-- ‡∏£‡∏≠‡∏ö‡πÅ‡∏£‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏°‡∏î
	ChooseMode()
	task.wait(5)

	-- ‡∏ß‡∏≤‡∏á‡∏¢‡∏π‡∏ô‡∏¥‡∏ï
	local pos1 = placeRaff1()
	print("üìå raff1 ‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà:", tostring(pos1))
	local id1 = placeUnitSafe(pos1, 1)
	print("üÜî raff1 ID:", id1)

	task.wait(6.5)

	local pos2 = placeRaff2()
	print("üìå raff2 ‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà:", tostring(pos2))
	local id2 = placeUnitSafe(pos2, 2)
	print("üÜî raff2 ID:", id2)

	task.wait(34.5)

	local pos3 = placeRaff3()
	print("üìå raff3 ‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà:", tostring(pos3))
	local id3 = placeUnitSafe(pos3, 1)
	print("üÜî raff3 ID:", id3)

	-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏¢‡∏π‡∏ô‡∏¥‡∏ï
	waitUntilCash(8000)
	upgradeUnitById(id3)
	task.wait(15)
	waitUntilCash(8000)
	upgradeUnitById(id2)

	-- ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó‡πÄ‡∏Å‡∏°
	again()
end

-- ===============================
-- üîÑ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö Event GameEnd
-- ===============================
ReplicatedStorage.RemoteEvents.ShowGameEnd.OnClientEvent:Connect(function()
	task.wait(2)
	runGameLoop()
end)

-- ===============================
-- üî• ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡πÅ‡∏£‡∏Å
-- ===============================
runGameLoop()
