local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local player = game.Players.LocalPlayer

local placedUnits = {}

-- üßÆ ‡πÅ‡∏õ‡∏•‡∏á string ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
local function parseNumber(str)
	str = tostring(str or "")
	local cleaned = str:gsub("[^%d]", "")
	return tonumber(cleaned) or 0
end

-- üí∞ ‡∏£‡∏≠‡∏à‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ñ‡∏∂‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
local function waitUntilCash(target)
	print("üü° ‡∏£‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏¥‡∏ô...")
	local gui = player:WaitForChild("PlayerGui"):WaitForChild("GameGui")
	local cashLabel = gui:WaitForChild("Screen"):WaitForChild("Bottom"):WaitForChild("CurrencyDisplay"):WaitForChild("Cash")

	while true do
		local cashValue = parseNumber(cashLabel.Text)
		print("üíµ ‡πÄ‡∏á‡∏¥‡∏ô‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ:", cashValue)
		if cashValue >= target then
			print("üí∞ ‡πÄ‡∏á‡∏¥‡∏ô‡∏ñ‡∏∂‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢:", target)
			break
		end
		task.wait(1)
	end
end

-- üîé ‡∏£‡∏≠‡∏à‡∏ô‡πÄ‡∏à‡∏≠ ID ‡∏Ç‡∏≠‡∏á unit
local function waitForUnitId(unitName, timeout)
	timeout = timeout or 15
	local startTime = tick()
	while tick() - startTime < timeout do
		local entities = Workspace:WaitForChild("Map"):WaitForChild("Entities")
		for _, unit in pairs(entities:GetChildren()) do
			local idAttr = unit:GetAttribute("ID")
			if unit.Name == unitName and idAttr and not placedUnits[idAttr] then
				placedUnits[idAttr] = unit
				return idAttr
			end
		end
		task.wait(0.2)
	end
	warn("‚ùå Timeout ‡πÑ‡∏°‡πà‡∏û‡∏ö unit:", unitName)
	return nil
end

-- üü¢ ‡∏ß‡∏≤‡∏á unit ‡πÅ‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ (retry ‡∏à‡∏ô‡πÑ‡∏î‡πâ ID)
local function placeUnitSafe(unitName, position, pathIndex)
	local id
	local attempts = 0
	repeat
		attempts += 1
		local args = {
			unitName,
			{
				Valid = true,
				PathIndex = pathIndex or 1,
				Position = position,
				DistanceAlongPath = 0,
				CF = CFrame.new(position),
				Rotation = 0
			}
		}
		ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("PlaceUnit"):InvokeServer(unpack(args))

		id = waitForUnitId(unitName, 15)

		if not id then
			warn("‚ö†Ô∏è ‡∏•‡∏≠‡∏á‡∏ß‡∏≤‡∏á unit ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà:", attempts)
			task.wait(1)
		end
	until id or attempts >= 3 -- retry 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
	return id
end

-- ‚¨ÜÔ∏è ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î unit
local function upgradeUnitById(id)
	if placedUnits[id] then
		local args = { id }
		ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("UpgradeUnit"):InvokeServer(unpack(args))
		print("üîº ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î unit ID:", id)
	else
		print("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö unit ID:", id)
	end
end

-- üïπÔ∏è ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏Å‡∏°
local function ChooseMode()
	local args = {"dif_apocalypse"}
	ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("PlaceDifficultyVote"):InvokeServer(unpack(args))
end

-- üîÅ ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó‡πÄ‡∏Å‡∏°
local function again()
	local restart = ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("RestartGame")
	pcall(function()
		restart:InvokeServer()
	end)
end

-- üì¢ ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏à‡∏ö‡πÄ‡∏Å‡∏°
local ShowGameEnd = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("ShowGameEnd")
ShowGameEnd.OnClientEvent:Connect(function()
	task.wait(2)
	again()
end)

-- üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
again()
ChooseMode()
task.wait(5)

-- ‡∏ß‡∏≤‡∏á unit
local id1 = placeUnitSafe("unit_rafflesia", Vector3.new(52.8052, -21.75, -55.8835), 1)
task.wait(13)
local id2 = placeUnitSafe("unit_rafflesia", Vector3.new(-51.1591, -21.75, -49.9755), 2)
task.wait(54)
local id3 = placeUnitSafe("unit_rafflesia", Vector3.new(52.6786, -21.75, -55.7569), 3)

-- ‡∏£‡∏≠‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î
waitUntilCash(8000)
upgradeUnitById(id3)
