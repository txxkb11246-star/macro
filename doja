local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local player = game.Players.LocalPlayer

local PlaceUnit = ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("PlaceUnit")

-- ===============================
-- üîπ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏£‡∏≠‡∏ö‡∏à‡∏∏‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏ô
-- ===============================
local function randomPositionAround(pos, radius)
    radius = radius or 5
    return Vector3.new(
        pos.X + (math.random() * 2 - 1) * radius,
        pos.Y,
        pos.Z + (math.random() * 2 - 1) * radius
    )
end

local lastPositions = { raff1=nil, raff2=nil, raff3=nil }

-- ===============================
-- üîπ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏á Raff ‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏° + ‡πÑ‡∏°‡πà‡∏ó‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°
-- ===============================
local function placeUnitRafflesia(unitName, pathIndex, basePos, minDist, maxDist, radius)
    radius = radius or 5
    local newPos
    local attempts = 0

    repeat
        newPos = randomPositionAround(basePos, radius)
        attempts += 1
    until lastPositions[unitName] ~= newPos or attempts > 10

    local distanceAlong = (minDist or 7) + math.random() * ((maxDist or 10) - (minDist or 7))

    local args = {
        "unit_rafflesia",
        {
            Valid = true,
            PathIndex = pathIndex,
            Position = newPos,
            DistanceAlongPath = distanceAlong,
            CF = CFrame.new(newPos),
            Rotation = 180
        }
    }

    local ok, err = pcall(function()
        PlaceUnit:InvokeServer(unpack(args))
    end)
    if not ok then warn("PlaceUnit failed:", err) end

    lastPositions[unitName] = newPos
    return newPos
end

-- ===============================
-- üîπ ‡∏à‡∏∏‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á raff
-- ===============================
local unitBases = {
    raff1 = Vector3.new(42.814, -21.75, -45.892),
    raff2 = Vector3.new(-44.658, -21.75, -43.475),
    raff3 = Vector3.new(41.676, -21.75, -44.754)
}

local function placeRaff1() return placeUnitRafflesia("raff1", 1, unitBases.raff1, 7, 10, 5) end
local function placeRaff2() return placeUnitRafflesia("raff2", 2, unitBases.raff2, 21, 24, 5) end
local function placeRaff3() return placeUnitRafflesia("raff3", 1, unitBases.raff3, 7, 10, 5) end

-- ==================================================
-- üî• ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á + ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏î‡πâ‡∏ß‡∏¢ ID
-- ==================================================
local placedUnits = {}

local function waitForUnitId(expectedPos, timeout)
    timeout = timeout or 15
    local start = tick()

    while tick() - start < timeout do
        for _, unit in pairs(Workspace.Map.Entities:GetChildren()) do
            local idAttr = unit:GetAttribute("ID")
            if idAttr and not placedUnits[idAttr] then
                if (unit:GetPivot().Position - expectedPos).Magnitude < 6 then
                    placedUnits[idAttr] = unit
                    return idAttr
                end
            end
        end
        task.wait(0.2)
    end
    return nil
end

local function placeUnitSafe(position, pathIndex)
    local id
    local attempts = 0

    repeat
        attempts += 1
        local args = {
            "unit_rafflesia",
            {
                Valid = true,
                PathIndex = pathIndex or 1,
                Position = position,
                DistanceAlongPath = 0,
                CF = CFrame.new(position),
                Rotation = 0
            }
        }

        PlaceUnit:InvokeServer(unpack(args))
        id = waitForUnitId(position, 15)

        if not id then
            warn("‚ö†Ô∏è ‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à retry:", attempts)
        end
    until id or attempts >= 3

    return id
end

local function upgradeUnitById(id)
    local unit = placedUnits[id]
    if unit then
        -- ‡∏™‡πà‡∏á instance ‡∏Ç‡∏≠‡∏á‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡πÑ‡∏õ‡∏ï‡∏£‡∏á ‡πÜ
        ReplicatedStorage.RemoteFunctions.UpgradeUnit:InvokeServer(unit)
        print("‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏¢‡∏π‡∏ô‡∏¥‡∏ï ID:", id)
    else
        warn("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö unit ID:", id)
    end
end

-- ===============================
-- üí∞ ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏á‡∏¥‡∏ô
-- ===============================
local function parseNumber(str)
    str = tostring(str or "")
    local cleaned = str:gsub("[^%d]", "")
    return tonumber(cleaned) or 0
end

local function waitUntilCash(target)
    local gui = player:WaitForChild("PlayerGui"):WaitForChild("GameGui")
    local cashLabel = gui.Screen.Bottom.CurrencyDisplay.Cash

    while true do
        local now = parseNumber(cashLabel.Text)
        if now >= target then break end
        task.wait(1)
    end
end

-- ===============================
-- üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
-- ===============================
local function ChooseMode()
    ReplicatedStorage.RemoteFunctions.PlaceDifficultyVote:InvokeServer("dif_apocalypse")
end

local function again()
    local r = ReplicatedStorage.RemoteFunctions.RestartGame
    pcall(function() r:InvokeServer() end)
end

ReplicatedStorage.RemoteEvents.ShowGameEnd.OnClientEvent:Connect(function()
    task.wait(2)
    again()
end)

-- ===============================
-- üéÆ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
-- ===============================
again()
ChooseMode()
task.wait(5)

-- üü¢ ‡∏ß‡∏≤‡∏á raff ‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
local pos1 = placeRaff1()
local id1 = placeUnitSafe(pos1, 1)

task.wait(13)

local pos2 = placeRaff2()
local id2 = placeUnitSafe(pos2, 2)

task.wait(69)

local pos3 = placeRaff3()
local id3 = placeUnitSafe(pos3, 1)

-- üí∞ ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ
waitUntilCash(8000)
upgradeUnitById(id3)

waitUntilCash(8000)
upgradeUnitById(id2)

waitUntilCash(8000)
upgradeUnitById(id1)
