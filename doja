local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local player = game.Players.LocalPlayer

local PlaceUnit = ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("PlaceUnit")
local UpgradeUnit = ReplicatedStorage:WaitForChild("RemoteFunctions"):WaitForChild("UpgradeUnit")

local lastPositions = {}

-- üîπ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏£‡∏≠‡∏ö‡∏ê‡∏≤‡∏ô ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ä‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°
local function randomPositionAround(pos, radius)
	radius = radius or 5
	local newPos
	local attempts = 0
	repeat
		newPos = Vector3.new(
			pos.X + (math.random() * 2 - 1) * radius,
			pos.Y,
			pos.Z + (math.random() * 2 - 1) * radius
		)
		attempts += 1
	until newPos ~= lastPositions[pos] or attempts > 10
	lastPositions[pos] = newPos
	return newPos
end

-- üîπ ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
local function parseNumber(str)
	str = tostring(str or "")
	local cleaned = str:gsub("[^%d]", "")
	return tonumber(cleaned) or 0
end

-- üîπ ‡∏£‡∏≠‡∏à‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ñ‡∏∂‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
local function waitUntilCash(target)
	local gui = player:WaitForChild("PlayerGui"):WaitForChild("GameGui")
	local cashLabel = gui.Screen.Bottom.CurrencyDisplay.Cash
	while parseNumber(cashLabel.Text) < target do
		task.wait(1)
	end
end

-- üîπ ‡∏´‡∏≤ ID ‡∏Ç‡∏≠‡∏á‡∏¢‡∏π‡∏ô‡∏¥‡∏ï
local function waitForUnitId(unitName, timeout)
	timeout = timeout or 15
	local start = tick()
	while tick() - start < timeout do
		local entities = Workspace.Map.Entities
		for _, unit in pairs(entities:GetChildren()) do
			local idAttr = unit:GetAttribute("ID")
			if unit.Name == unitName and idAttr then
				return idAttr
			end
		end
		task.wait(0.2)
	end
	return nil
end

-- üîπ ‡∏ß‡∏≤‡∏á‡∏¢‡∏π‡∏ô‡∏¥‡∏ï
local function placeUnit(unitName, pathIndex, basePos, minDist, maxDist, radius)
	local newPos = randomPositionAround(basePos, radius)
	local distanceAlong = (minDist or 7) + math.random() * ((maxDist or 10) - (minDist or 7))
	local args = {
		"unit_rafflesia",
		{
			Valid = true,
			PathIndex = pathIndex,
			Position = newPos,
			DistanceAlongPath = distanceAlong,
			CF = CFrame.new(newPos),
			Rotation = 180
		}
	}
	local ok, err = pcall(function() PlaceUnit:InvokeServer(unpack(args)) end)
	if not ok then warn("PlaceUnit failed:", err) end
	local id = waitForUnitId("unit_rafflesia", 15)
	return id, newPos
end

-- üîπ ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏ï‡∏≤‡∏° ID
local function upgradeUnitById(id)
	if not id then return end
	UpgradeUnit:InvokeServer(id)
end

-- ===============================
-- üîπ ‡∏à‡∏∏‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á‡∏¢‡∏π‡∏ô‡∏¥‡∏ï
-- ===============================
local unitConfigs = {
	{ key="raff1", pathIndex=1, basePos=Vector3.new(42.814, -21.75, -45.892), minDist=7, maxDist=10, radius=5, upgradeCost=8000, waitAfterPlace=13 },
	{ key="raff2", pathIndex=2, basePos=Vector3.new(-44.658, -21.75, -43.475), minDist=21, maxDist=24, radius=5, upgradeCost=8000, waitAfterPlace=69 },
	{ key="raff3", pathIndex=1, basePos=Vector3.new(41.676, -21.75, -44.754), minDist=7, maxDist=10, radius=5, upgradeCost=8000, waitAfterPlace=0 },
}

-- üîπ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
local function ChooseMode()
	ReplicatedStorage.RemoteFunctions.PlaceDifficultyVote:InvokeServer("dif_apocalypse")
end

local function again()
	local r = ReplicatedStorage.RemoteFunctions.RestartGame
	pcall(function() r:InvokeServer() end)
end

-- üîπ ‡∏ß‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö
local function PlaceAndUpgradeAll()
	again()
	ChooseMode()
	task.wait(5)

	for i = 1, #unitConfigs do
		local config = unitConfigs[i]
		local id, pos = placeUnit("unit_rafflesia", config.pathIndex, config.basePos, config.minDist, config.maxDist, config.radius)
		print("üìå ‡∏ß‡∏≤‡∏á", config.key, "‡∏ó‡∏µ‡πà:", pos, "ID:", id)

		-- ‡∏£‡∏≠‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß
		if config.waitAfterPlace and config.waitAfterPlace > 0 then
			task.wait(config.waitAfterPlace)
		end

		-- ‡∏£‡∏≠‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß
		waitUntilCash(config.upgradeCost)
		upgradeUnitById(id)
		print("‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î", config.key, "‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢")
	end
end

-- üîπ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
PlaceAndUpgradeAll()
