--==================================================
-- üåø SCRIPT ‡∏£‡∏ß‡∏° AUTO FARM + ‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á + GUI ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î + ‡∏õ‡πâ‡∏≤‡∏¢‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ö‡∏ô‡∏™‡∏∏‡∏î‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠
--==================================================

-- ===============================
-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏´‡∏•‡∏±‡∏Å
-- ===============================
local enabled = false
local farmThread = nil
local intervalRaff = 60
local WAIT_AFTER_MODE_MIN = 5.5
local WAIT_AFTER_MODE_MAX = 6
local WAIT_AFTER_PLACE_MIN = 55
local WAIT_AFTER_PLACE_MAX = 65

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RemoteFuncs = ReplicatedStorage:WaitForChild("RemoteFunctions")
local PlaceUnit = RemoteFuncs:WaitForChild("PlaceUnit")
local player = game.Players.LocalPlayer

-- ===============================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ö‡∏ô‡∏™‡∏∏‡∏î‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠
-- ===============================
local function showTopMessage(text, duration)
	local gui = Instance.new("ScreenGui")
	gui.IgnoreGuiInset = true
	gui.ResetOnSpawn = false
	gui.Parent = player:WaitForChild("PlayerGui")

	local label = Instance.new("TextLabel")
	label.AnchorPoint = Vector2.new(0.5, 0)
	label.Position = UDim2.new(0.5, 0, 0, 20)
	label.Size = UDim2.new(0.8, 0, 0, 80)
	label.BackgroundTransparency = 0.4
	label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.Font = Enum.Font.SourceSansBold
	label.Text = text
	label.TextSize = 60
	label.TextStrokeTransparency = 0
	label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	label.TextWrapped = true
	label.Parent = gui

	task.delay(duration or 2, function()
		gui:Destroy()
	end)
end

-- ===============================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
-- ===============================
local function randomPositionAround(pos, radius)
	local randX = pos.X + (math.random() * 2 - 1) * radius
	local randY = pos.Y
	local randZ = pos.Z + (math.random() * 2 - 1) * radius
	return Vector3.new(randX, randY, randZ)
end

-- ===============================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏°‡∏î
-- ===============================
local function selectmode()
	local args = {"dif_apocalypse"}
	local ok, err = pcall(function()
		RemoteFuncs:WaitForChild("PlaceDifficultyVote"):InvokeServer(unpack(args))
	end)
	if not ok then
		warn("‚ùå PlaceDifficultyVote failed:", err)
	end
end

-- ===============================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏á‡∏¢‡∏π‡∏ô‡∏¥‡∏ï
-- ===============================
local function placeRafflesia(pathIndex, basePos, minDist, maxDist, radius)
	radius = radius or 5
	local newPos = randomPositionAround(basePos, radius)
	local distanceAlong = (minDist or 7) + math.random() * ((maxDist or 10) - (minDist or 7))

	local args = {
		"unit_rafflesia",
		{
			Valid = true,
			PathIndex = pathIndex,
			Position = newPos,
			DistanceAlongPath = distanceAlong,
			CF = CFrame.new(newPos),
			Rotation = 180
		}
	}

	local ok, err = pcall(function()
		PlaceUnit:InvokeServer(unpack(args))
	end)
	if not ok then
		warn("‚ùå PlaceUnit failed:", err)
	end

	return newPos
end

-- ===============================
-- raff1 / raff2
-- ===============================
function raff1()
	local basePos = Vector3.new(42.814170837402344, -21.75, -45.892452239990234)
	placeRafflesia(1, basePos, 7, 10, 5)
end

function raff2()
	local basePos = Vector3.new(-44.65868377685547, -21.75, -43.47500991821289)
	placeRafflesia(2, basePos, 21, 24, 5)
end

-- ===============================
-- raff3 + upgrade
-- ===============================
-- ===============================
-- raff3: ‡∏ß‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏£‡∏≠ Seeds ‚â• 8000 ‡πÅ‡∏•‡πâ‡∏ß‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏ô‡∏±‡πâ‡∏ô
-- ===============================
function raff3()
        local basePos = Vector3.new(42.814170837402344, -21.75, -45.892452239990234)
    local newPos = randomPositionAround(basePos, 5)
    
    local args = {
        "unit_rafflesia",
        {
            Valid = true,
            PathIndex = 1,
            Position = newPos,
            DistanceAlongPath = 7 + math.random() * (10 - 7),
            CF = CFrame.new(newPos),
            Rotation = 180
        }
    }
    PlaceUnit:InvokeServer(unpack(args))
end


-- ===============================
-- ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó‡πÄ‡∏Å‡∏°
-- ===============================
function playagain()
	local ok, err = pcall(function()
		RemoteFuncs:WaitForChild("RestartGame"):InvokeServer()
	end)
	if not ok then warn("‚ùå RestartGame failed:", err) end
end

-- ===============================
-- ‡∏•‡∏π‡∏õ‡∏´‡∏•‡∏±‡∏Å
-- ===============================
local function autoFarmLoop()
	while enabled do
		selectmode()
		task.wait(math.random(WAIT_AFTER_MODE_MIN, WAIT_AFTER_MODE_MAX))
		raff1()
		task.wait(10)
		raff2()
		task.wait(34)
		raff3_upgrade_wait()
		task.wait(intervalRaff)
		playagain()
		task.wait(math.random(WAIT_AFTER_PLACE_MIN, WAIT_AFTER_PLACE_MAX))
	end
end

-- ===============================
-- GUI ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î
-- ===============================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "JhonJustGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local button = Instance.new("TextButton")
button.Size = UDim2.new(0, 180, 0, 50)
button.Position = UDim2.new(1, -190, 0, 10)
button.BackgroundColor3 = Color3.fromRGB(100, 200, 255)
button.TextColor3 = Color3.fromRGB(0, 0, 0)
button.Font = Enum.Font.SourceSansBold
button.TextSize = 20
button.Text = "JhonJust : OFF"
button.Parent = screenGui

-- ‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏≤‡∏Å‡πÑ‡∏î‡πâ
local UIS = game:GetService("UserInputService")
local dragging, dragStart, startPos, dragInput

button.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = button.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then dragging = false end
		end)
	end
end)

button.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		dragInput = input
	end
end)

UIS.InputChanged:Connect(function(input)
	if dragging and input == dragInput then
		local delta = input.Position - dragStart
		local newX = startPos.X.Offset + delta.X
		local newY = startPos.Y.Offset + delta.Y
		local viewport = workspace.CurrentCamera.ViewportSize
		newX = math.clamp(newX, 0, viewport.X - button.AbsoluteSize.X)
		newY = math.clamp(newY, 0, viewport.Y - button.AbsoluteSize.Y)
		button.Position = UDim2.new(0, newX, 0, newY)
	end
end)

-- ===============================
-- ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏£‡∏∞‡∏ö‡∏ö
-- ===============================
button.MouseButton1Click:Connect(function()
	if enabled then
		enabled = false
		button.Text = "JhonJust : OFF"
		showTopMessage("üò¥ ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏ñ‡∏¥‡∏î‡∏≠‡∏≤‡∏ô‡∏ô‡∏ó‡πå", 3)
	else
		enabled = true
		button.Text = "JhonJust : ON"
		showTopMessage("üòé ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡πÉ‡∏à‡πÄ‡∏¢‡πá‡∏ô‡∏ß‡∏±‡∏¢‡∏£‡∏∏‡πà‡∏ô ...", 2)
		if farmThread then task.cancel(farmThread) end
		farmThread = task.spawn(autoFarmLoop)
	end
end)
